使用线程池的注意事项：
1、死锁：
    例如：线程A持有对象X，线程B持有线程Y，A等待Y的锁，B等待X的锁，双方都不释放，并且等待对方的锁形成永久等待
    又例如：假设线程池中所有的工作线程在执行个字任务时都被阻塞，都在等待任务A的结果，然而任务A此时还在等待队列中，又没有空闲的工作线程，
    将会导致所有线程永久阻塞
2、系统资源不足：基本原因是过多的线程导致资源开销太大，从而严重影响系统性能
3、并发错误：
    工作队列依靠wait()和notify()两个方法使线程获得任务，但这两个方法难于使用，一旦编码错误，可能导致工作线程一直保持空闲而无视队列中的任务。
    建议使用较为成熟的线程池（JDK自带的或者。。）
4、线程泄露：
    对于工作线程数目固定的线程池，如果工作线程在工作期间抛出RuntimeException 或 Error，并且这些异常没有被捕获到，那么这个线程就会异常终止，
    使得线程池永久失去一个工作线程。如果类似情况多次发生，极有可能导致所有工作线程全部终止，从而导致系统失去处理能力。
    另一种线程泄露的情形是，工作线程执行一个任务时被阻塞（如等待用户的输入，但是用户一直不输入）这样的工作线程名存实亡，它实际上不执行任务了，
    一旦全部的工作线程都进入这种状况，那么线程池也就无法处理新加入的任务了。（本质上可理解为，可用的工作线程减少）
5、任务过载：
    当工作任务队列中存在大量的排队任务时，这些任务本身就可能消耗太多的系统资源而引起系统资源缺乏。

结论：综上所述，线程池可能带来种种风险，为了尽可能的避免它们，使用线程池时需要遵循以下原则：
    （1）、如果任务A需要等待任务B的执行结果，那么任务A不适合加入到线程池的工作队列中；
    （2）、如果执行到某个任务时可能会阻塞，并且是长时间的阻塞，则应该设定超时时间，避免工作线程永久的阻塞下去而导致线程泄露。在服务器程序中，
    当线程等待客户连接，或者等待客户发送的数据时，都可能会阻塞。可以通过以下方式设定超时时间：
        A、调用ServerSocket()的setSoTimeout(int timeout)方法，设定等待客户连接的超时时间
        B、调用每个与客户端连接的socket，调用该socket的setsoTimeout(int timeout)方法，设定等待用户发送数据超时时间。
    （3）、了解任务的特点，分析任务是类似于I/O一类的经常会阻塞的任务，还是执行不会阻塞的计算任务，前者时断时续的利用CPU后者利用CPU比较高效，
     预计任务花费多少时间？段时间任务还是长时间任务？
            根据任务特点，对任务进行分类，然后把不同的任务放到不同类型的线程池的工作队列中，根据任务的特点，分别调整各自的线程池。
     （4）、调整线程池的大小，线程池的大小主要取决于可用CPU的数目，以及工作队列中任务的特点。假设具有N个CPU的系统上只有一个任务队列，并且全部是
     计算任务，那么当线程池具有N或N+1个线程时CPU会获得最大效率。如果工作队列中包含有I/O操作常常大声阻塞的任务，则要让线程池的大小超过任务数量，
     因为并非所有工作线程在一直工作。估算线程数量的方法是：N= CPU数目 *（1+WT/ST），WT：等待时间，ST：实际占用CPU运算的时间。
    除了要考虑CPU利用率之外，随着工作线程的增加，还会碰到内存或者其他系统资源的限制，如套接字、打开的文件句柄或数据库链接。要保证多线程小号的
    资源在系统的可承载范围之内。
    （5）、避免任务过载，服务器根据系统的承载能力，限制客户并发链接的数目，当客户并发的连接数目超过了限制值，服务器科技拒绝连接请求，并友好的
    告知客户并发连接的数目超过了限制值，服务器可以拒绝连接请求，并友好的告知用户系统正忙，请稍后再试。
